apiVersion: batch/v1
kind: Job
metadata:
  name: postgres-restore
  namespace: postgres
  labels:
    app.kubernetes.io/name: postgres-restore
    app.kubernetes.io/component: restore
spec:
  ttlSecondsAfterFinished: 3600
  backoffLimit: 2
  template:
    metadata:
      labels:
        app.kubernetes.io/name: postgres-restore
    spec:
      restartPolicy: Never
      serviceAccountName: postgres-restore
      containers:
        - name: restore
          image: postgres:17
          env:
            - name: BACKUP_DATE
              value: "interactive"
            - name: POSTGRES_STATEFULSET_NAME
              value: "postgres"
            - name: KUBECTL_NAMESPACE
              value: "postgres"
            - name: POSTGRES_POD_LABEL
              value: "app.kubernetes.io/name=postgres"
            - name: MINIO_LABEL
              value: "app.kubernetes.io/name=minio"
            - name: S3_BUCKET
              value: "backups"
            - name: BACKUP_PREFIX
              value: "postgres"
            - name: INCREMENTAL_BACKUP
              value: ""
            - name: APPLY_INCREMENTALS
              value: "false"
            - name: REMOTE_S3_MODE
              value: "false"
            - name: S3_ENDPOINT_URL
              value: ""
            - name: S3_ACCESS_KEY
              value: ""
            - name: S3_SECRET_KEY
              value: ""
            - name: PVC_NAME
              value: "postgres-data-postgres-0"
          command:
            - /bin/bash
            - -c
            - |
              set -Eeo pipefail

              echo "========================================="
              echo "PostgreSQL 还原任务"
              echo "========================================="
              echo "备份日期: ${BACKUP_DATE}"
              echo "命名空间: ${KUBECTL_NAMESPACE}"
              echo "StatefulSet: ${POSTGRES_STATEFULSET_NAME}"
              echo "PVC: ${PVC_NAME}"
              echo "========================================="

              # 安装必要工具
              apt-get update -qq
              apt-get install -y -qq kubectl curl zstd > /dev/null

              RESTORE_WORK_DIR="/tmp/restore"
              TARGET_DIR="/restore/target"

              if [ "${REMOTE_S3_MODE}" = "true" ]; then
                ARCH=$(uname -m)
                case "$ARCH" in
                  x86_64) MC_ARCH="amd64" ;;
                  aarch64|arm64) MC_ARCH="arm64" ;;
                  *) echo "错误: 不支持的架构 $ARCH"; exit 1 ;;
                esac
                curl -sSL https://dl.min.io/client/mc/release/linux-${MC_ARCH}/mc -o /usr/local/bin/mc
                chmod +x /usr/local/bin/mc
                mc alias set remote "${S3_ENDPOINT_URL}" "${S3_ACCESS_KEY}" "${S3_SECRET_KEY}" --api S3v4
                S3_ALIAS="remote"
              else
                MINIO_POD=$(kubectl get pods -n "${KUBECTL_NAMESPACE}" -l "${MINIO_LABEL}" -o jsonpath='{.items[0].metadata.name}')
                if [ -z "${MINIO_POD}" ]; then
                  echo "错误: 未找到 MinIO Pod"
                  exit 1
                fi
                echo "MinIO Pod: ${MINIO_POD}"
              fi

              BACKUP_PATH="${S3_BUCKET}/${BACKUP_PREFIX}/${BACKUP_DATE}"

              if [ "${REMOTE_S3_MODE}" = "true" ]; then
                mc ls "${S3_ALIAS}/${BACKUP_PATH}/" > /dev/null || { echo "错误: 备份不存在"; exit 1; }
              else
                kubectl exec -n "${KUBECTL_NAMESPACE}" "${MINIO_POD}" -- mc ls "${BACKUP_PATH}/" > /dev/null || { echo "错误: 备份不存在"; exit 1; }
              fi

              echo "停止 PostgreSQL StatefulSet..."
              kubectl scale statefulset "${POSTGRES_STATEFULSET_NAME}" -n "${KUBECTL_NAMESPACE}" --replicas=0

              echo "等待 Pod 终止..."
              kubectl wait --for=delete pod -l "${POSTGRES_POD_LABEL}" -n "${KUBECTL_NAMESPACE}" --timeout=300s || true

              rm -rf "${RESTORE_WORK_DIR}"
              mkdir -p "${RESTORE_WORK_DIR}"
              mkdir -p "${TARGET_DIR}"

              if [ "${REMOTE_S3_MODE}" = "true" ]; then
                FULL_BACKUP=$(mc ls "${S3_ALIAS}/${BACKUP_PATH}/" | grep "full-.*\.tar\.zst" | awk '{print $NF}' | head -n1)
                [ -z "${FULL_BACKUP}" ] && { echo "错误: 未找到全量备份"; exit 1; }
                mc cat "${S3_ALIAS}/${BACKUP_PATH}/${FULL_BACKUP}" | zstd -dc --threads=0 | tar -x -C "${RESTORE_WORK_DIR}" -f -
              else
                FULL_BACKUP=$(kubectl exec -n "${KUBECTL_NAMESPACE}" "${MINIO_POD}" -- mc ls "${BACKUP_PATH}/" | grep "full-.*\.tar\.zst" | awk '{print $NF}' | head -n1)
                [ -z "${FULL_BACKUP}" ] && { echo "错误: 未找到全量备份"; exit 1; }
                kubectl exec -n "${KUBECTL_NAMESPACE}" "${MINIO_POD}" -- mc cat "${BACKUP_PATH}/${FULL_BACKUP}" | zstd -dc --threads=0 | tar -x -C "${RESTORE_WORK_DIR}" -f -
              fi

              BACKUP_DIR=$(find "${RESTORE_WORK_DIR}" -mindepth 1 -maxdepth 1 -type d -name "*-full-*" | head -n1)
              if [ -z "${BACKUP_DIR}" ]; then
                echo "错误: 未找到解压目录"
                exit 1
              fi
              echo "全量备份目录: ${BACKUP_DIR}"

              COMBINE_DIRS=("${BACKUP_DIR}")

              if [ -n "${INCREMENTAL_BACKUP}" ] || [ "${APPLY_INCREMENTALS}" = "true" ]; then
                INCREMENTAL_PATH="${BACKUP_PATH}/incremental"
                if [ "${APPLY_INCREMENTALS}" = "true" ]; then
                  if [ "${REMOTE_S3_MODE}" = "true" ]; then
                    INCREMENTALS=$(mc ls "${S3_ALIAS}/${INCREMENTAL_PATH}/" 2>/dev/null | grep "incremental.*\.tar\.zst" | awk '{print $NF}' | sort)
                  else
                    INCREMENTALS=$(kubectl exec -n "${KUBECTL_NAMESPACE}" "${MINIO_POD}" -- mc ls "${INCREMENTAL_PATH}/" 2>/dev/null | grep "incremental.*\.tar\.zst" | awk '{print $NF}' | sort)
                  fi
                else
                  INCREMENTALS="${INCREMENTAL_BACKUP}"
                fi

                if [ -n "${INCREMENTALS}" ]; then
                  idx=1
                  while IFS= read -r inc; do
                    [ -z "${inc}" ] && continue
                    INC_WORK_DIR="${RESTORE_WORK_DIR}/incremental_${idx}"
                    mkdir -p "${INC_WORK_DIR}"
                    if [ "${REMOTE_S3_MODE}" = "true" ]; then
                      mc cat "${S3_ALIAS}/${INCREMENTAL_PATH}/${inc}" | zstd -dc --threads=0 | tar -x -C "${INC_WORK_DIR}" -f -
                    else
                      kubectl exec -n "${KUBECTL_NAMESPACE}" "${MINIO_POD}" -- mc cat "${INCREMENTAL_PATH}/${inc}" | zstd -dc --threads=0 | tar -x -C "${INC_WORK_DIR}" -f -
                    fi
                    INC_DIR=$(find "${INC_WORK_DIR}" -mindepth 1 -maxdepth 1 -type d | head -n1)
                    [ -z "${INC_DIR}" ] && { echo "错误: 增量备份 ${inc} 解压失败"; exit 1; }
                    COMBINE_DIRS+=("${INC_DIR}")
                    idx=$((idx + 1))
                  done <<< "${INCREMENTALS}"
                fi
              fi

              echo "清空目标目录..."
              rm -rf "${TARGET_DIR:?}/"*

              if ! command -v pg_combinebackup >/dev/null 2>&1; then
                echo "错误: 未找到 pg_combinebackup"
                exit 1
              fi

              echo "执行 pg_combinebackup..."
              pg_combinebackup -o "${TARGET_DIR}" "${COMBINE_DIRS[@]}"

              sync
              chmod 700 "${TARGET_DIR}" || true
              chown -R 999:999 "${TARGET_DIR}" || true

              rm -rf "${RESTORE_WORK_DIR}"

              echo "启动 PostgreSQL StatefulSet..."
              kubectl scale statefulset "${POSTGRES_STATEFULSET_NAME}" -n "${KUBECTL_NAMESPACE}" --replicas=1

              echo "等待 PostgreSQL 就绪..."
              if ! kubectl rollout status statefulset/"${POSTGRES_STATEFULSET_NAME}" \
                -n "${KUBECTL_NAMESPACE}" --timeout=600s; then
                echo "StatefulSet 未在超时时间内完成，改为等待 Pod 就绪"
                kubectl wait --for=condition=ready pod -l "${POSTGRES_POD_LABEL}" \
                  -n "${KUBECTL_NAMESPACE}" --timeout=300s || true
              fi

              echo "验证 PostgreSQL..."
              sleep 30
              kubectl exec -n "${KUBECTL_NAMESPACE}" statefulset/"${POSTGRES_STATEFULSET_NAME}" -- pg_isready -U postgres

              echo "========================================="
              echo "还原成功完成"
              echo "========================================="
          resources:
            requests:
              memory: "512Mi"
              cpu: "200m"
            limits:
              memory: "2Gi"
              cpu: "1000m"
          volumeMounts:
            - name: postgres-data
              mountPath: /restore/target
            - name: restore-work
              mountPath: /tmp
      volumes:
        - name: postgres-data
          persistentVolumeClaim:
            claimName: postgres-data-postgres-0
        - name: restore-work
          emptyDir:
            sizeLimit: 20Gi
